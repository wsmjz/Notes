(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{491:function(t,v,_){t.exports=_.p+"assets/img/docker.5b6320e6.jpg"},529:function(t,v,_){"use strict";_.r(v);var a=_(58),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"向上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向上"}},[t._v("#")]),t._v(" 向上")]),t._v(" "),a("blockquote",[a("p",[t._v("有了一定的目的性，并且有了合理的"),a("a",{attrs:{href:"https://juejin.im/post/6844903919722692621",target:"_blank",rel:"noopener noreferrer"}},[t._v("练习方法"),a("OutboundLink")],1),a("br")])]),t._v(" "),a("ul",[a("li",[t._v("注意，一定是分类练习！分类练习！分类练习！重要的事情说三遍。")]),t._v(" "),a("li",[t._v("刻意练习")])]),t._v(" "),a("h2",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://github.com/ConardLi/awesome-coding-js",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章"),a("OutboundLink")],1)])]),t._v(" "),a("ul",[a("li",[t._v("数据结构即数据元素相互之间存在的一种和多种特定的关系集合。")]),t._v(" "),a("li",[t._v("一般你可以从两个维度来理解它，逻辑结构和存储结构。")]),t._v(" "),a("li",[t._v("队")]),t._v(" "),a("li",[t._v("栈")])]),t._v(" "),a("blockquote",[a("p",[t._v("先进后出")])]),t._v(" "),a("ul",[a("li",[t._v("ast语法解析")]),t._v(" "),a("li",[t._v("怎么解析html片段 生成语法树?")]),t._v(" "),a("li",[t._v("队列")])]),t._v(" "),a("blockquote",[a("p",[t._v("先进先出")])]),t._v(" "),a("ul",[a("li",[t._v("数组")]),t._v(" "),a("li",[t._v("链表")]),t._v(" "),a("li",[t._v("集合")]),t._v(" "),a("li",[t._v("hash表")]),t._v(" "),a("li",[t._v("二叉树")])]),t._v(" "),a("blockquote",[a("p",[t._v("遍历，对称性，搜索树，树的深度")])]),t._v(" "),a("ul",[a("li",[t._v("中序遍历")]),t._v(" "),a("li",[t._v("前序遍历")]),t._v(" "),a("li",[t._v("后序遍历")]),t._v(" "),a("li",[t._v("字符串")])]),t._v(" "),a("h2",{attrs:{id:"服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染"}},[t._v("#")]),t._v(" 服务端渲染")]),t._v(" "),a("ul",[a("li",[t._v("静态化和服务端渲染是两个概念：静态化是说你把页面用nuxt之类的弄成html页面，里面的文本内容都在html里填充好了，是在你打包的时候就填充的，请求的就是静态文件；服务端渲染===ssr，并不等于静态化，是在服务端，在你请求的时候把html里动态填充上内容才返回给你的，并不是在你打包的时候填充的")])]),t._v(" "),a("h2",{attrs:{id:"微前端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端"}},[t._v("#")]),t._v(" 微前端")]),t._v(" "),a("ul",[a("li",[t._v("技术细节\n"),a("ul",[a("li",[t._v("样式隔离")]),t._v(" "),a("li",[t._v("window 沙箱")]),t._v(" "),a("li",[t._v("通信机制（应用之间如何互相通信）")])])]),t._v(" "),a("li",[t._v("singleSpa\n"),a("ul",[a("li",[t._v("主应用")]),t._v(" "),a("li",[t._v("子应用")])])]),t._v(" "),a("li",[t._v("qiankun")]),t._v(" "),a("li",[t._v("沙箱")]),t._v(" "),a("li",[t._v("方案\n"),a("ul",[a("li",[t._v("iframe")]),t._v(" "),a("li",[t._v("web-component\n"),a("ul",[a("li",[t._v("web component 是浏览器自带的一套 runtime，它提供 shadow dom，能够完全隔离 css")])])])])]),t._v(" "),a("li",[t._v("讨论\n"),a("ul",[a("li",[t._v('抛出一个疑问，微前端究竟是为了"微"还是兼容不同框架？这两者有本质不同，如果只是为了"微"，那么各种隔离都不需要做，因为本质上就是把大项目拆分，本身他们之间就不会有任何影响。而只是兼容不同框架，那么这个意义不大，谁会在一个公司为了用不同的框架从而维护好几套 ui 框架 [看看你] 不觉得累么。除非就是拿微前端来填坑，把旧的东西很难重构的页面杂糅在一起，而这个本质上已经偏离了真正微前端的意义了')]),t._v(" "),a("li",[t._v("微组件挺好，我就一个 WebCompoent，你不用管我用 R/V/A/j，反正给你的就是一个 js 和一个 tag，你自己调用就行了。所以一个页面充满着 R/V/A/j 问题也不大。就和 Docker 一样，data 进来了，我给你 trans 出 你想要的 data 就行啦，至于怎么实现的，用什么技术实现的，对不起，这不重要，我也不想关心，调用就完了")]),t._v(" "),a("li",[t._v("就是主应用加载子应用js文件")])])])]),t._v(" "),a("h2",{attrs:{id:"模版引擎实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模版引擎实现原理"}},[t._v("#")]),t._v(" 模版引擎实现原理")]),t._v(" "),a("h2",{attrs:{id:"web安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web安全"}},[t._v("#")]),t._v(" web安全")]),t._v(" "),a("h2",{attrs:{id:"网络协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络协议"}},[t._v("#")]),t._v(" 网络协议")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/Java3y/p/8444033.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("TCP握手协议(http)")]),t._v(" "),a("li",[t._v("状态码具体含义")])]),t._v(" "),a("h2",{attrs:{id:"网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),a("p",[t._v("浏览器如何解析js  清晰网络请求控制台各项表示 红蓝条 - 网络请求时间 - 本地渲染时间  / 对象实例化后的作用，流程结果及渲染到浏览器")]),t._v(" "),a("ul",[a("li",[t._v("http和https的区别？\n"),a("ul",[a("li",[t._v("https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密。")]),t._v(" "),a("li",[t._v("http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少")])])]),t._v(" "),a("li",[t._v("输入Url到网页加载完成的过程？")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("dns解析 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("》 连接tcp协议（"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("次握手） "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("》 浏览器请求服务器返回空html "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("》 浏览器渲染dom"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("css 发起ajax 请求服务器数据 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("》 服务器返回数据填充Dom "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("》 断开连接（"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("次挥手）\n")])])]),a("ul",[a("li",[t._v("axios\n"),a("ul",[a("li",[t._v("有些情况需要创建多个axios 实例 可以进行不同配置（因为我们实际工作项目中，可能需要访问多个服务地址，而这些服务请求和响应的结构也可能都完全不同，那么你可以通过axios.create创建不同的实例来处理。） "),a("a",{attrs:{href:"https://www.jianshu.com/p/636aa0e565a5",target:"_blank",rel:"noopener noreferrer"}},[t._v("地址"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("实例可以直接调用方法, 可以传参 构造函数调用静态方法   理解axios 默认会返回一个实例")]),t._v(" "),a("li",[t._v("键值对数据传递模式 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';")]),t._v(" "),a("li",[t._v("json数据传递模式 axios.defaults.headers.post['Content-Type'] = 'application/json'")])])])]),t._v(" "),a("h3",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),a("ul",[a("li",[t._v("post请求 页面刷新不会保留，量大，安全")]),t._v(" "),a("li",[t._v("get 页面刷新 会缓存？，量小，不安全")]),t._v(" "),a("li",[t._v("delete")]),t._v(" "),a("li",[t._v("等等")])]),t._v(" "),a("h3",{attrs:{id:"存储区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储区别"}},[t._v("#")]),t._v(" 存储区别")]),t._v(" "),a("ul",[a("li",[t._v("cookit")]),t._v(" "),a("li",[t._v("sesstion")])]),t._v(" "),a("h3",{attrs:{id:"跨域处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域处理"}},[t._v("#")]),t._v(" 跨域处理")]),t._v(" "),a("p",[t._v("九种跨域实现")]),t._v(" "),a("ol",[a("li",[t._v("http地址跨域")]),t._v(" "),a("li",[t._v("jsonp")]),t._v(" "),a("li",[t._v("proxy")])]),t._v(" "),a("h3",{attrs:{id:"接口请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口请求"}},[t._v("#")]),t._v(" 接口请求")]),t._v(" "),a("ul",[a("li",[t._v("General")]),t._v(" "),a("li",[t._v("Response Headers")]),t._v(" "),a("li",[t._v("Request Headers")]),t._v(" "),a("li",[t._v("参数方式\n"),a("ul",[a("li",[t._v("Post方式：Request Payload （data参数为new FormData() / new URLSearchParams()）")]),t._v(" "),a("li",[t._v("Get方式：\n"),a("ul",[a("li",[t._v("Form Data  （地址栏有参数，data参数为json格式）")]),t._v(" "),a("li",[t._v("Query String Parameters (地址栏有参数，data没有携带参数)")])])])])])]),t._v(" "),a("h3",{attrs:{id:"http-协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[t._v("#")]),t._v(" http 协议")]),t._v(" "),a("ul",[a("li",[t._v("原理 / 理解")]),t._v(" "),a("li",[t._v("网络数据请求流程，安全证书")])]),t._v(" "),a("blockquote",[a("p",[t._v("转到进阶网络协议")])]),t._v(" "),a("h2",{attrs:{id:"进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进阶"}},[t._v("#")]),t._v(" 进阶")]),t._v(" "),a("ul",[a("li",[t._v("let 和 var 的存储地址不同")]),t._v(" "),a("li",[t._v("函数式编程\n"),a("ol",[a("li",[t._v("柯里化(curry函数应用参数列表的顺序是从左到最右)")]),t._v(" "),a("li",[t._v("偏函数(partial函数应用参数列表的顺序是从左到最右)")])])])]),t._v(" "),a("h3",{attrs:{id:"组件库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件库"}},[t._v("#")]),t._v(" 组件库")]),t._v(" "),a("ul",[a("li",[t._v("http://gitlab.shishike.com/front_end/kryfe-components")]),t._v(" "),a("li",[t._v("http://gitlab.shishike.com/front_end/kryfe-component-ts")]),t._v(" "),a("li",[t._v("通用库：kryfe-lib")])]),t._v(" "),a("h3",{attrs:{id:"构建工具-cli"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建工具-cli"}},[t._v("#")]),t._v(" 构建工具(cli)")]),t._v(" "),a("ul",[a("li",[t._v("http://gitlab.shishike.com/front_end/kryfe-tools")])]),t._v(" "),a("h3",{attrs:{id:"代码检查工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码检查工具"}},[t._v("#")]),t._v(" 代码检查工具")]),t._v(" "),a("ul",[a("li",[t._v("http://gitlab.shishike.com/front_end/stylelint-config-kryfe")]),t._v(" "),a("li",[t._v("http://gitlab.shishike.com/front_end/eslint-config-kryfe")]),t._v(" "),a("li",[t._v("http://gitlab.shishike.com/front_end/kryfe-style-mobile")])]),t._v(" "),a("h3",{attrs:{id:"docker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker"}},[t._v("#")]),t._v(" docker")]),t._v(" "),a("ul",[a("li",[t._v("http://gitlab.shishike.com/front_end/kryfe-nginx-docker")])]),t._v(" "),a("h2",{attrs:{id:"浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),a("h3",{attrs:{id:"缓存优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存优化"}},[t._v("#")]),t._v(" 缓存优化")]),t._v(" "),a("blockquote",[a("p",[t._v("304")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/54cc04190252",target:"_blank",rel:"noopener noreferrer"}},[t._v("缓存机制"),a("OutboundLink")],1),t._v(" 百度：浏览器的缓存机制")]),t._v(" "),a("li",[t._v("强制缓存")]),t._v(" "),a("li",[t._v("协商缓存")])]),t._v(" "),a("h3",{attrs:{id:"垃圾回收机制原理（v8引擎）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制原理（v8引擎）"}},[t._v("#")]),t._v(" 垃圾回收机制原理（v8引擎）")]),t._v(" "),a("ul",[a("li",[t._v("如何实现的垃圾回收")])]),t._v(" "),a("h3",{attrs:{id:"浏览器是如何渲染的（渲染原理）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是如何渲染的（渲染原理）"}},[t._v("#")]),t._v(" 浏览器是如何渲染的（渲染原理）")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/8fd2311546f8",target:"_blank",rel:"noopener noreferrer"}},[t._v("原理"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("输入地址亲求服务器 服务器返回html文件")]),t._v(" "),a("li",[t._v("开始载入全部的html代码，发现标签内有一个标签引用外部CSS文件，浏览器又发出CSS文件的请求，服务器返回这个CSS文件；")]),t._v(" "),a("li",[t._v("回流，重绘")])]),t._v(" "),a("h3",{attrs:{id:"前端项目是如何运行的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端项目是如何运行的"}},[t._v("#")]),t._v(" 前端项目是如何运行的")]),t._v(" "),a("ul",[a("li",[t._v("HTML,CSS,JS都是在浏览器中渲染执行的，确切的说是浏览器内核做的事情，渲染引擎和JavaScript执行引擎。")]),t._v(" "),a("li",[t._v("如果是现代vue，react等框架，一般都会使用webpack构建工具，它会做一些处理例如css预处理器的解析、css前缀补全、es6+新语法向老语法的转换等等操作，都是在本地nodejs环境执行的，编译打包过后方可在浏览器端执行。")])]),t._v(" "),a("h2",{attrs:{id:"敏捷开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#敏捷开发"}},[t._v("#")]),t._v(" 敏捷开发")]),t._v(" "),a("ul",[a("li",[t._v("流程")]),t._v(" "),a("li",[t._v("特点\n"),a("ul",[a("li",[t._v("尽早交付，从用户反馈，迭代更新")])])])]),t._v(" "),a("h2",{attrs:{id:"前端sdk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端sdk"}},[t._v("#")]),t._v(" 前端SDK")]),t._v(" "),a("blockquote",[a("p",[t._v("完善的SDK叫做框架-"),a("a",{attrs:{href:"https://www.zhihu.com/question/20225153",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章"),a("OutboundLink")],1)])]),t._v(" "),a("ul",[a("li",[t._v("优惠券计算SDK")])]),t._v(" "),a("h2",{attrs:{id:"前端监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端监控"}},[t._v("#")]),t._v(" 前端监控")]),t._v(" "),a("blockquote",[a("p",[t._v("更好服务产品")])]),t._v(" "),a("ul",[a("li",[t._v("性能\n"),a("ul",[a("li",[t._v("DNS查询时间")]),t._v(" "),a("li",[t._v("TCP链接时间")]),t._v(" "),a("li",[t._v("request请求时间")]),t._v(" "),a("li",[t._v("白屏时间")]),t._v(" "),a("li",[t._v("首屏时间")]),t._v(" "),a("li",[t._v("可交互时间")]),t._v(" "),a("li",[t._v("总下载时间")]),t._v(" "),a("li",[t._v("dom下载时间")])])]),t._v(" "),a("li",[t._v("错误")])]),t._v(" "),a("blockquote",[a("p",[t._v("更好地及时发现，定位错误")])]),t._v(" "),a("ul",[a("li",[t._v("js错误")]),t._v(" "),a("li",[t._v("用户信息")]),t._v(" "),a("li",[t._v("api请求地址")]),t._v(" "),a("li",[t._v("分辨率")]),t._v(" "),a("li",[t._v("json错误")]),t._v(" "),a("li",[t._v("用户行为")])]),t._v(" "),a("h2",{attrs:{id:"爬虫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#爬虫"}},[t._v("#")]),t._v(" 爬虫")]),t._v(" "),a("h2",{attrs:{id:"工程化-运维-jenkins配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工程化-运维-jenkins配置"}},[t._v("#")]),t._v(" 工程化.运维 (jenkins配置)")]),t._v(" "),a("ul",[a("li",[t._v("配置短命令"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('vi ~/gitconfig\n[alias]\n   a = add -A\n   c = commit -m "init"\n   p = push origin master \n')])])])]),t._v(" "),a("li",[t._v("CI(持续集成)CD持续部署")]),t._v(" "),a("li",[t._v("docker\n"),a("ul",[a("li",[t._v("Docker属于Linux容器的一种封装，提供简单易用的容器使用接口")]),t._v(" "),a("li",[t._v("Docker将应用程序与该程序的依赖，打包在一个文件里面，运行这个文件就会生成一个"),a("code",[t._v("虚拟容器")]),t._v(" 程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样\n"),a("ul",[a("li",[t._v("Docker比虚拟机更加轻量级 性能更高 centos(虚拟机4-5G) docker 40-50M\n"),a("img",{attrs:{src:_(491),alt:""}})])])])])]),t._v(" "),a("li",[t._v("开始 创建3个github项目\n"),a("blockquote",[a("p",[t._v("前端，服务端项目提交会向 webhook 链接的服务器（http://39.106.107:3000/webhook ）发送请求，webhook服务器 docker部署")])]),t._v(" "),a("ul",[a("li",[t._v("前端项目（配置webhook 密钥 请求方式 连接的服务器等，比如http://39.106.107:3000/webhook）")]),t._v(" "),a("li",[t._v("服务端项目（配置webhook 密钥 请求方式 连接的服务器等，比如http://39.106.107:3000/webhook）")]),t._v(" "),a("li",[t._v("webhook项目(CICD服务器)\n"),a("ul",[a("li",[t._v("webhook.js中 创建服务 // 上面配置的 这儿监听3000端口\n"),a("ul",[a("li",[t._v("判断 路劲是不是 上面配置的"),a("code",[t._v("/webhook")])])])]),t._v(" "),a("li",[t._v("提交前后端项目 这儿就会收到请求")])])])])]),t._v(" "),a("li",[t._v("操作Xshell（在Xshell中）\n"),a("ul",[a("li",[t._v("下载 git")]),t._v(" "),a("li",[t._v("下载前端(vue-front) 服务端(vue-back)项目(生成公钥 免输密码)\n"),a("ul",[a("li",[t._v("git clone ...项目")]),t._v(" "),a("li",[t._v("ssh-keygen -t rsa -b ...（免密）")]),t._v(" "),a("li",[t._v("cat 查找文件 查看生成公钥（Xshell内容）")])])]),t._v(" "),a("li",[t._v("下载node(nvm 管理node 可以存在多个node版本)\n"),a("ul",[a("li",[t._v("nvm install stable 同时安装node npm")]),t._v(" "),a("li",[t._v("npm install nrm -g (切换安装源)")]),t._v(" "),a("li",[t._v("开放阿里云接口")])])]),t._v(" "),a("li",[t._v("安装docker\n"),a("ul",[a("li",[t._v("安装阿里云镜像")])])]),t._v(" "),a("li",[t._v("安装启动服务\n"),a("ul",[a("li",[t._v("cd vue-front/back 进入前端/服务端文件夹")]),t._v(" "),a("li",[t._v("npm i 安装依赖")]),t._v(" "),a("li",[t._v("npm start 启动项目")])])])])])]),t._v(" "),a("h3",{attrs:{id:"流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程图"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"http://www.sohu.com/a/338934428_100299155",target:"_blank",rel:"noopener noreferrer"}},[t._v("流程图"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("编码 => 构建(build, 安装依赖等) => 测试 => 集成(分支测试通过，集成到主干) => 交付 => 部署\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/2414212-120ea11d15068afd",alt:"avatar"}})]),t._v(" "),a("ol",[a("li",[t._v("编码到集成 叫做 持续集成")]),t._v(" "),a("li",[t._v("编码到交付 叫做 持续交付")]),t._v(" "),a("li",[t._v("编码到部署 叫做 持续部署")])]),t._v(" "),a("h3",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" webpack")]),t._v(" "),a("h3",{attrs:{id:"自动化测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动化测试"}},[t._v("#")]),t._v(" 自动化测试")]),t._v(" "),a("h3",{attrs:{id:"自动化部署-一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动化部署-一次"}},[t._v("#")]),t._v(" 自动化部署(一次)")]),t._v(" "),a("ol",[a("li",[t._v("webHook")]),t._v(" "),a("li",[t._v("Docker镜像 Nglix代理")])]),t._v(" "),a("h3",{attrs:{id:"持续集成（continuous-integration，简称-ci）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持续集成（continuous-integration，简称-ci）"}},[t._v("#")]),t._v(" 持续集成（Continuous integration，简称 CI）")]),t._v(" "),a("ul",[a("li",[t._v("关键：(持续， 多次)"),a("a",{attrs:{href:"https://www.jianshu.com/p/c200884960ac",target:"_blank",rel:"noopener noreferrer"}},[t._v("解释1"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://www.jianshu.com/p/78e03a140125",target:"_blank",rel:"noopener noreferrer"}},[t._v("解释2"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("概念")])]),t._v(" "),a("blockquote",[a("p",[t._v("1、持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度（以上引用自Martin Fowler 对持续集成的定义）。"),a("br"),t._v("\n2、持续集成指的是，频繁地（一天多次）将代码集成到主干")])]),t._v(" "),a("ul",[a("li",[t._v("为什么使用\n时常我们会被集成折磨得焦头烂额。有很多团队只是担心，并没有拿出有效的措施去避免这种事情发生，以至于延长了交付时间。既然担心，我们何不及早集成，把问题先暴露出来？ 最后集成会出现很多问题，所以提前这样去把问题暴露出来")]),t._v(" "),a("li",[t._v("好处")])]),t._v(" "),a("blockquote",[a("p",[t._v("1、快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。"),a("br"),t._v("\n2、防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。"),a("br"),t._v("\n3、减少风险"),a("br"),t._v("\n4、减少重复过程")])]),t._v(" "),a("ul",[a("li",[t._v("目的")])]),t._v(" "),a("blockquote",[a("p",[t._v("持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。\nMartin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”")])]),t._v(" "),a("ul",[a("li",[t._v("工具")])]),t._v(" "),a("blockquote",[a("p",[t._v("GitHub 上比较主流的持续集成工具有 Travis CI 和 Circle CI；分别占市场占有率前两位，两者的功能和使用都比较相似，其中Travis CI用的最多")])]),t._v(" "),a("ul",[a("li",[t._v("总结\n"),a("blockquote",[a("p",[t._v("1、持续突出的就是一个"),a("strong",[t._v("快")]),t._v("字，商业软件的快速落地需求推动了软件工程的发展。可持续的、"),a("strong",[t._v("快速迭代")]),t._v("的软件过程是当今主流开发规约。尤其在互联网行业，快速响应即是生命线。从一个想法到产品落地都处在冲锋的过程中，机会稍纵即逝。响应用户反馈也是万分"),a("strong",[t._v("敏捷")]),t._v("，早晨的反馈在当天就会上线发布，快得让用户感觉倍受重视。“快”已经成为商业竞争力。这一切都要求企业具备快速响应的能力，这正是推动持续集成、持续交付、持续部署的动力"),a("br"),t._v("\n2、产品或者项目的参与者应该能够深刻体会到团队协作时，工作交接（系统集成）部分最容易出问题，会消耗大量的沟通成本与时间成本，直接拖慢进度。所以，一个行之有效的项目管理过程（包括沟通管理、流程管理）在大型项目中效果明显。当前"),a("strong",[t._v("敏捷开发")]),t._v("是主流，持续集成、持续交付与持续部署正好能够帮助高效地实施敏捷过程，促进开发、运维和质量保障（QA）部门之间的沟通、协作与整合")])])])]),t._v(" "),a("h4",{attrs:{id:"ci-cd-带来的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd-带来的变化"}},[t._v("#")]),t._v(" CI&CD 带来的变化")]),t._v(" "),a("p",[t._v("目前多数公司都已经使用了版本管理工具来管理源码，比如GitLab、SVN 等版本管理工具。在版本管理这一块，公司会根据自己的实际情况来制订版本管理办法。对于持续集成来说，业内建议只维护一个源码仓库，降低版本管理的复杂度。开发人员"),a("strong",[t._v("持续提交自己的修改，自动触发编译，自动集成，自动进行自动化的测试")]),t._v("，及早反馈集成过程中的问题，就能更好地防止出现平时不集成、集成就出问题的现象"),a("br"),t._v("\n通过自动化的持续集成，把管理流程固化；保证集成的有序性、可靠性；减少版本发布的不合规性（开发或者测试手动打包，可能一天打多个包，更新多次，测试不充分），保证版本可控，问题可追溯（至于哪个版本出现的问题，可以回溯）。"),a("br")]),t._v(" "),a("p",[t._v("一旦把这种持续集成的过程固定下来，形成一个自动化过程，就具备了持续集成的能力，软件交付的可靠性就大大增强，这无形也是一种竞争力。这种竞争力保证了集成的有序性、可靠性。过程的自动化抛弃了人工，降低了出错率，提高了速度，自然会节省成本。")]),t._v(" "),a("h4",{attrs:{id:"ci-cd-实施现状"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd-实施现状"}},[t._v("#")]),t._v(" CI&CD 实施现状")]),t._v(" "),a("p",[t._v("在日常生活中处处都体现着一个“快”字，互联网更是对快追求到极致。持续集成、持续交付、持续部署在互联网行业更为广泛。作者没有统计哪些公司在用，只是圈子中朋友公司都实施了持续集成，具备持续交付能力。至于持续部署就没这么广泛了，毕竟"),a("strong",[t._v("持续部署不仅仅是技术问题，还涉及管理、营运等问题")]),t._v("。尤其是一些金融企业、大型国企，开发团队外包，测试外包，运营半外包，安全要求高，很难快速实施。多数能够在测试环境中建立起CI&CD就已经很不错了。"),a("br")]),t._v(" "),a("p",[t._v("阿里云、腾讯云、网易蜂巢等国内云，都提供了从GitLab 下拉代码、编译打包、单元测试、镜像制作、容器发布的功能。这个过程实际上就是持续集成、持续交付的过程，同时具有持续部署的能力。基本上，持续集成、持续交付、持续部署是一种服务能力，是云平台必须具备的能力。")]),t._v(" "),a("h4",{attrs:{id:"ci-cd-技术栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd-技术栈"}},[t._v("#")]),t._v(" CI&CD 技术栈")]),t._v(" "),a("p",[t._v("目前持续集成、持续交付、持续部署在开源社区都是热点，用户可以方便地利用这些开源组件来构建自己企业的持续集成、持续交付及持续部署平台。"),a("br")]),t._v(" "),a("p",[t._v("持续集成工具中以Jenkins 使用最为广泛，由Jenkins 来作业化持续集成过程；利用GitLab来管理程序版本；利用Gerrit 来做代码审核；利用"),a("strong",[t._v("Sonar 进行代码质量扫描")]),t._v("；利用JUnit 进行单元测试；利用Docker compose 来构建镜像；利用Docker 来部署容器；利用Kubernetes、Rancher 等进行服务编排。\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/2414212-ab595553429f08c3",alt:"avatar"}})]),t._v(" "),a("h3",{attrs:{id:"持续交付"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持续交付"}},[t._v("#")]),t._v(" 持续交付")]),t._v(" "),a("p",[t._v("持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。\n持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。")]),t._v(" "),a("h3",{attrs:{id:"持续部署"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持续部署"}},[t._v("#")]),t._v(" 持续部署")]),t._v(" "),a("ul",[a("li",[t._v("持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。")]),t._v(" "),a("li",[t._v("持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。")]),t._v(" "),a("li",[t._v("持续部署的前提是能自动化完成测试、构建、部署等步骤")]),t._v(" "),a("li",[t._v("流程")])]),t._v(" "),a("ol",[a("li",[t._v("提交代码(commit)\n流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。")]),t._v(" "),a("li",[t._v("测试(第一轮)\n"),a("ul",[a("li",[t._v("代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。")]),t._v(" "),a("li",[t._v("测试有好几种。")])]),t._v(" "),a("ol",[a("li",[t._v("单元测试：针对函数或模块的测试")]),t._v(" "),a("li",[t._v("集成测试：针对整体产品的某个功能的测试，又称功能测试")]),t._v(" "),a("li",[t._v("端对端测试：从用户界面直达数据库的全链路测试\n第一轮至少要跑单元测试。")])])]),t._v(" "),a("li",[t._v("构建")])]),t._v(" "),a("blockquote",[a("p",[t._v("通过第一轮测试，代码就可以合并进主干，就算可以交付了。\n交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。\n常用的构建工具如下。")])]),t._v(" "),a("ul",[a("li",[t._v("Jenkins")]),t._v(" "),a("li",[t._v("Travis")]),t._v(" "),a("li",[t._v("Codeship")]),t._v(" "),a("li",[t._v("Strider")])]),t._v(" "),a("blockquote",[a("p",[t._v("Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("测试(第二轮)")])]),t._v(" "),a("blockquote",[a("p",[t._v("构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。\n第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。\n需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("部署")])]),t._v(" "),a("blockquote",[a("p",[t._v("通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible，Chef，Puppet 等。")])]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[t._v("回滚")])]),t._v(" "),a("blockquote",[a("p",[t._v("一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。")])]),t._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),a("ul",[a("li",[t._v("ServerLess")]),t._v(" "),a("li",[t._v("GrapSQL")]),t._v(" "),a("li",[t._v("Mobx")]),t._v(" "),a("li",[t._v("nest.js")]),t._v(" "),a("li",[t._v("桌面应用")])]),t._v(" "),a("h2",{attrs:{id:"api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" api")]),t._v(" "),a("ul",[a("li",[t._v("浏览器底层api\n"),a("ul",[a("li",[t._v("requestIdcallbackkk()")])])]),t._v(" "),a("li",[t._v("Element对象")])]),t._v(" "),a("comment-comment")],1)}),[],!1,null,null,null);v.default=r.exports}}]);